(* generated by Ott 0.31 from: isla_lang.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
(* Require Import Ott.ott_list_core. *)



Require Import String.
Require Import ZArith.

Inductive isla_var : Type :=
| Mk_isla_var : nat -> isla_var.

Inductive register_name : Type :=  (* register and field names *)
| Mk_register_name : string -> register_name.

Inductive enum_id : Type :=
| Mk_enum_id : nat -> enum_id.

Inductive enum_ctor : Type :=
| Mk_enum_ctor : nat -> enum_ctor.

Inductive annot : Type :=
| Mk_annot : annot.

Definition enum : Set := (enum_id*enum_ctor).

Inductive bvmanyarith : Set := 
 | Bvand : bvmanyarith
 | Bvor : bvmanyarith
 | Bvxor : bvmanyarith
 | Bvadd : bvmanyarith
 | Bvmul : bvmanyarith.

Inductive bvcomp : Set := 
 | Bvult : bvcomp
 | Bvslt : bvcomp
 | Bvule : bvcomp
 | Bvsle : bvcomp
 | Bvuge : bvcomp
 | Bvsge : bvcomp
 | Bvugt : bvcomp
 | Bvsgt : bvcomp.

Inductive bvarith : Set := 
 | Bvnand : bvarith
 | Bvnor : bvarith
 | Bvxnor : bvarith
 | Bvsub : bvarith
 | Bvudiv : bvarith
 | Bvudivi : bvarith
 | Bvsdiv : bvarith
 | Bvsdivi : bvarith
 | Bvurem : bvarith
 | Bvsrem : bvarith
 | Bvsmod : bvarith
 | Bvshl : bvarith
 | Bvlshr : bvarith
 | Bvashr : bvarith.

Inductive manyop : Set := 
 | And : manyop
 | Or : manyop
 | Bvmanyarith (bvmanyarith5:bvmanyarith)
 | Concat : manyop.

Inductive unop : Set := 
 | Not : unop
 | Bvnot : unop
 | Bvredand : unop
 | Bvredor : unop
 | Bvneg : unop
 | Extract (int5:Z) (int':Z)
 | ZeroExtend (int5:Z)
 | SignExtend (int5:Z).

Inductive binop : Set := 
 | Eq : binop
 | Bvarith (bvarith5:bvarith)
 | Bvcomp (bvcomp5:bvcomp).

Inductive valu : Set := 
 | Val_Symbolic (vvar5:isla_var)
 | Val_Bool (bool5:bool)
 | Val_I (bvi5:Z) (int5:Z)
 | Val_Bits (bv5:string)
 | Val_Enum (enum5:enum)
 | Val_String (str5:string)
 | Val_Unit : valu
 | Val_NamedUnit (name5:register_name)
 | Val_Vector (_:list valu)
 | Val_List (_:list valu)
 | Val_Struct (_:list register_name * valu)
 | Val_Poison : valu.

Inductive accessor : Set := 
 | Field (name5:register_name).

Inductive ty : Set := 
 | Ty_Bool : ty
 | Ty_BitVec (int5:Z)
 | Ty_Enum (enum_ty5:enum_id)
 | Ty_Array (ty1:ty) (ty2:ty).

Inductive exp : Set := 
 | Var (vvar5:isla_var) (annot5:unit)
 | Bits (bv5:string) (annot5:unit)
 | Bool (bool5:bool) (annot5:unit)
 | Enum (enum5:enum) (annot5:unit)
 | Unop (unop5:unop) (exp5:exp) (annot5:unit)
 | Binop (binop5:binop) (exp1:exp) (exp2:exp) (annot5:unit)
 | Manyop (manyop5:manyop) (_:list exp) (annot5:unit)
 | Ite (exp1:exp) (exp2:exp) (exp3:exp) (annot5:unit).

Definition valu_option : Set := option valu.

Inductive accessor_list : Set := 
 | Nil : accessor_list
 | Cons (_:list accessor).

Inductive smt : Set := 
 | DeclareConst (vvar5:isla_var) (ty5:ty)
 | DefineConst (vvar5:isla_var) (exp5:exp)
 | Assert (exp5:exp)
 | DefineEnum (int5:Z).

Inductive event : Set := 
 | Smt (smt5:smt) (annot5:unit)
 | Branch (int5:Z) (str5:string) (annot5:unit) (*r Sail trace fork *)
 | ReadReg (name5:register_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:unit) (*r read register *)
 | WriteReg (name5:register_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:unit) (*r write register *)
 | ReadMem (valu5:valu) (rkind:valu) (addr:valu) (nat5:nat) (tag_value:valu_option) (annot5:unit) (*r read memory *)
 | WriteMem (vvar5:isla_var) (wkind:valu) (addr:valu) (data:valu) (nat5:nat) (tag_value:valu_option) (annot5:unit) (*r write memory *)
 | BranchAddress (addr:valu) (annot5:unit) (*r announce branch address, to induce ctrl dependency in concurrency model *)
 | Barrier (bkind:valu) (annot5:unit) (*r memory barrier *)
 | CacheOp (ckind:valu) (addr:valu) (annot5:unit) (*r cache maintenance effect, for data-cache clean etc. *)
 | MarkReg (name5:register_name) (str5:string) (annot5:unit) (*r instrumentation to tell concurrency model to ignore certain dependencies (TODO: support marking multiple registers). Currently the str is ignore-edge or ignore-write *)
 | Cycle (annot5:unit) (*r instruction boundary *)
 | Instr (opcode:valu) (annot5:unit) (*r records the instruction opcode that was fetched *)
 | Sleeping (vvar5:isla_var) (annot5:unit) (*r Arm sleeping predicate *)
 | WakeRequest (annot5:unit) (*r Arm wake request *)
 | SleepRequest (annot5:unit) (*r Arm sleep request *).

Inductive trc : Set := 
 | Trace (_:list event).
(** induction principles *)
Section exp_rect.

Variables
  (P_list_exp : list exp -> Prop)
  (P_exp : exp -> Prop).

Hypothesis
  (H_Var : forall (vvar5:isla_var), forall (annot5:unit), P_exp (Var vvar5 annot5))
  (H_Bits : forall (bv5:string), forall (annot5:unit), P_exp (Bits bv5 annot5))
  (H_Bool : forall (bool5:bool), forall (annot5:unit), P_exp (Bool bool5 annot5))
  (H_Enum : forall (enum5:enum), forall (annot5:unit), P_exp (Enum enum5 annot5))
  (H_Unop : forall (unop5:unop), forall (exp5:exp), P_exp exp5 -> forall (annot5:unit), P_exp (Unop unop5 exp5 annot5))
  (H_Binop : forall (binop5:binop), forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (annot5:unit), P_exp (Binop binop5 exp1 exp2 annot5))
  (H_Manyop : forall (exp_list:list exp), P_list_exp exp_list -> forall (manyop5:manyop), forall (annot5:unit), P_exp (Manyop manyop5 exp_list annot5))
  (H_Ite : forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (exp3:exp), P_exp exp3 -> forall (annot5:unit), P_exp (Ite exp1 exp2 exp3 annot5))
  (H_list_exp_nil : P_list_exp nil)
  (H_list_exp_cons : forall (exp0:exp), P_exp exp0 -> forall (exp_l:list exp), P_list_exp exp_l -> P_list_exp (cons exp0 exp_l)).

Fixpoint exp_ott_ind (n:exp) : P_exp n :=
  match n as x return P_exp x with
  | (Var vvar5 annot5) => H_Var vvar5 annot5
  | (Bits bv5 annot5) => H_Bits bv5 annot5
  | (Bool bool5 annot5) => H_Bool bool5 annot5
  | (Enum enum5 annot5) => H_Enum enum5 annot5
  | (Unop unop5 exp5 annot5) => H_Unop unop5 exp5 (exp_ott_ind exp5) annot5
  | (Binop binop5 exp1 exp2 annot5) => H_Binop binop5 exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) annot5
  | (Manyop manyop5 exp_list annot5) => H_Manyop exp_list (((fix exp_list_ott_ind (exp_l:list exp) : P_list_exp exp_l := match exp_l as x return P_list_exp x with nil => H_list_exp_nil | cons exp1 xl => H_list_exp_cons exp1(exp_ott_ind exp1)xl (exp_list_ott_ind xl) end)) exp_list) manyop5 annot5
  | (Ite exp1 exp2 exp3 annot5) => H_Ite exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) exp3 (exp_ott_ind exp3) annot5
end.

End exp_rect.


