(* generated by Ott 0.31 from: isla_lang.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.



Require Import String.
Require Import ZArith.

Inductive isla_var : Type :=
| Mk_isla_var : nat -> isla_var.

Inductive register_name : Type :=  (* register and field names *)
| Mk_register_name : string -> register_name.

Inductive enum_id : Type :=
| Mk_enum_id : nat -> enum_id.

Inductive enum_ctor : Type :=
| Mk_enum_ctor : nat -> enum_ctor.

Inductive annot : Type :=
| Mk_annot : annot.

Definition enum : Set := (enum_id*enum_ctor).

Inductive bvmanyarith : Set := 
 | Bvand : bvmanyarith
 | Bvor : bvmanyarith
 | Bvxor : bvmanyarith
 | Bvadd : bvmanyarith
 | Bvmul : bvmanyarith.

Inductive bvcomp : Set := 
 | Bvult : bvcomp
 | Bvslt : bvcomp
 | Bvule : bvcomp
 | Bvsle : bvcomp
 | Bvuge : bvcomp
 | Bvsge : bvcomp
 | Bvugt : bvcomp
 | Bvsgt : bvcomp.

Inductive bvarith : Set := 
 | Bvnand : bvarith
 | Bvnor : bvarith
 | Bvxnor : bvarith
 | Bvsub : bvarith
 | Bvudiv : bvarith
 | Bvudivi : bvarith
 | Bvsdiv : bvarith
 | Bvsdivi : bvarith
 | Bvurem : bvarith
 | Bvsrem : bvarith
 | Bvsmod : bvarith
 | Bvshl : bvarith
 | Bvlshr : bvarith
 | Bvashr : bvarith.

Inductive manyop : Set := 
 | And : manyop
 | Or : manyop
 | Bvmanyarith (bvmanyarith5:bvmanyarith)
 | Concat : manyop.

Inductive unop : Set := 
 | Not : unop
 | Bvnot : unop
 | Bvredand : unop
 | Bvredor : unop
 | Bvneg : unop
 | Extract (int5:Z) (int':Z)
 | ZeroExtend (int5:Z)
 | SignExtend (int5:Z).

Inductive binop : Set := 
 | Eq : binop
 | Bvarith (bvarith5:bvarith)
 | Bvcomp (bvcomp5:bvcomp).

Inductive accessor : Set := 
 | Field (name5:register_name).

Inductive ty : Set := 
 | Ty_Bool : ty
 | Ty_BitVec (int5:Z)
 | Ty_Enum (enum_ty5:enum_id)
 | Ty_Array (ty1:ty) (ty2:ty).

Inductive exp : Set := 
 | Var (vvar5:isla_var) (annot5:unit)
 | Bits (bv5:string) (annot5:unit)
 | Bool (bool5:bool) (annot5:unit)
 | Enum (enum5:enum) (annot5:unit)
 | Unop (unop5:unop) (exp5:exp) (annot5:unit)
 | Binop (binop5:binop) (exp1:exp) (exp2:exp) (annot5:unit)
 | Manyop (manyop5:manyop) (_:list exp) (annot5:unit)
 | Ite (exp1:exp) (exp2:exp) (exp3:exp) (annot5:unit).

Inductive valu : Set := 
 | Val_Symbolic (vvar5:isla_var)
 | Val_Bool (bool5:bool)
 | Val_I (bvi5:Z) (int5:Z)
 | Val_Bits (bv5:string)
 | Val_Enum (enum5:enum)
 | Val_String (str5:string)
 | Val_Unit : valu
 | Val_NamedUnit (name5:register_name)
 | Val_Vector (_:list valu)
 | Val_List (_:list valu)
 | Val_Struct (_:list register_name * valu)
 | Val_Poison : valu.

Inductive accessor_list : Set := 
 | Nil : accessor_list
 | Cons (_:list accessor).

Inductive smt : Set := 
 | DeclareConst (vvar5:isla_var) (ty5:ty)
 | DefineConst (vvar5:isla_var) (exp5:exp)
 | Assert (exp5:exp)
 | DefineEnum (int5:Z).

Definition valu_option : Set := option valu.

Inductive event : Set := 
 | Smt (smt5:smt) (annot5:unit)
 | Branch (int5:Z) (str5:string) (annot5:unit) (*r Sail trace fork *)
 | ReadReg (name5:register_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:unit) (*r read value `valu` from register `name` *)
 | WriteReg (name5:register_name) (accessor_list5:accessor_list) (valu5:valu) (annot5:unit) (*r write value `valu` to register `name` *)
 | ReadMem (valu5:valu) (rkind:valu) (addr:valu) (num_bytes:nat) (tag_value:valu_option) (annot5:unit) (*r read value `valu` from memory address `addr`, with read kind `rkind`, byte width `byte_width`, and `tag_value` is the optional capability tag *)
 | WriteMem (vvar5:isla_var) (wkind:valu) (addr:valu) (data:valu) (num_bytes:nat) (tag_value:valu_option) (annot5:unit) (*r write value `valu` to memory address `addr`, with write kind `wkind`, byte width `byte_width`, `tag_value` is the optional capability tag, and success flag `vvar` *)
 | BranchAddress (addr:valu) (annot5:unit) (*r announce branch address `addr`, to induce ctrl dependency in the concurrency model *)
 | Barrier (bkind:valu) (annot5:unit) (*r memory barrier of kind `bkind` *)
 | CacheOp (ckind:valu) (addr:valu) (annot5:unit) (*r cache maintenance effect of kind `ckind`, at address `addr`, for data-cache clean etc. *)
 | MarkReg (name5:register_name) (str5:string) (annot5:unit) (*r instrumentation to tell concurrency model to ignore certain dependencies (TODO: support marking multiple registers). Currently the str is ignore-edge or ignore-write *)
 | Cycle (annot5:unit) (*r instruction boundary *)
 | Instr (opcode:valu) (annot5:unit) (*r records the instruction `opcode` that was fetched *)
 | Sleeping (vvar5:isla_var) (annot5:unit) (*r Arm sleeping predicate *)
 | WakeRequest (annot5:unit) (*r Arm wake request *)
 | SleepRequest (annot5:unit) (*r Arm sleep request *).

Inductive valu_concrete : Set := 
 | CVal_Bool (bool5:bool)
 | CVal_I (bvi5:Z) (int5:Z)
 | CVal_Bits (bv5:string)
 | CVal_Enum (enum5:enum)
 | CVal_String (str5:string)
 | CVal_Unit : valu_concrete
 | CVal_NamedUnit (name5:register_name)
 | CVal_Vector (_:list valu)
 | CVal_List (_:list valu)
 | CVal_Struct (_:list register_name * valu)
 | CVal_Poison : valu_concrete.

Inductive trc : Set := 
 | Trace (_:list event).

Inductive exp_val : Set := 
 | EV_Bits (bv5:string) (annot5:unit)
 | EV_Bool (bool5:bool) (annot5:unit)
 | EV_Enum (enum5:enum) (annot5:unit)
 | EV_Unop (unop5:unop) (exp_val5:exp_val) (annot5:unit)
 | EV_Binop (binop5:binop) (exp_val1:exp_val) (exp_val2:exp_val) (annot5:unit)
 | EV_Manyop (manyop5:manyop) (_:list exp_val) (annot5:unit)
 | EV_Ite (exp_val1:exp_val) (exp_val2:exp_val) (exp_val3:exp_val) (annot5:unit).
(** induction principles *)
Section exp_rect.

Variables
  (P_list_exp : list exp -> Prop)
  (P_exp : exp -> Prop).

Hypothesis
  (H_Var : forall (vvar5:isla_var), forall (annot5:unit), P_exp (Var vvar5 annot5))
  (H_Bits : forall (bv5:string), forall (annot5:unit), P_exp (Bits bv5 annot5))
  (H_Bool : forall (bool5:bool), forall (annot5:unit), P_exp (Bool bool5 annot5))
  (H_Enum : forall (enum5:enum), forall (annot5:unit), P_exp (Enum enum5 annot5))
  (H_Unop : forall (unop5:unop), forall (exp5:exp), P_exp exp5 -> forall (annot5:unit), P_exp (Unop unop5 exp5 annot5))
  (H_Binop : forall (binop5:binop), forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (annot5:unit), P_exp (Binop binop5 exp1 exp2 annot5))
  (H_Manyop : forall (exp_list:list exp), P_list_exp exp_list -> forall (manyop5:manyop), forall (annot5:unit), P_exp (Manyop manyop5 exp_list annot5))
  (H_Ite : forall (exp1:exp), P_exp exp1 -> forall (exp2:exp), P_exp exp2 -> forall (exp3:exp), P_exp exp3 -> forall (annot5:unit), P_exp (Ite exp1 exp2 exp3 annot5))
  (H_list_exp_nil : P_list_exp nil)
  (H_list_exp_cons : forall (exp0:exp), P_exp exp0 -> forall (exp_l:list exp), P_list_exp exp_l -> P_list_exp (cons exp0 exp_l)).

Fixpoint exp_ott_ind (n:exp) : P_exp n :=
  match n as x return P_exp x with
  | (Var vvar5 annot5) => H_Var vvar5 annot5
  | (Bits bv5 annot5) => H_Bits bv5 annot5
  | (Bool bool5 annot5) => H_Bool bool5 annot5
  | (Enum enum5 annot5) => H_Enum enum5 annot5
  | (Unop unop5 exp5 annot5) => H_Unop unop5 exp5 (exp_ott_ind exp5) annot5
  | (Binop binop5 exp1 exp2 annot5) => H_Binop binop5 exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) annot5
  | (Manyop manyop5 exp_list annot5) => H_Manyop exp_list (((fix exp_list_ott_ind (exp_l:list exp) : P_list_exp exp_l := match exp_l as x return P_list_exp x with nil => H_list_exp_nil | cons exp1 xl => H_list_exp_cons exp1(exp_ott_ind exp1)xl (exp_list_ott_ind xl) end)) exp_list) manyop5 annot5
  | (Ite exp1 exp2 exp3 annot5) => H_Ite exp1 (exp_ott_ind exp1) exp2 (exp_ott_ind exp2) exp3 (exp_ott_ind exp3) annot5
end.

End exp_rect.


Section exp_val_rect.

Variables
  (P_list_exp_val : list exp_val -> Prop)
  (P_exp_val : exp_val -> Prop).

Hypothesis
  (H_EV_Bits : forall (bv5:string), forall (annot5:unit), P_exp_val (EV_Bits bv5 annot5))
  (H_EV_Bool : forall (bool5:bool), forall (annot5:unit), P_exp_val (EV_Bool bool5 annot5))
  (H_EV_Enum : forall (enum5:enum), forall (annot5:unit), P_exp_val (EV_Enum enum5 annot5))
  (H_EV_Unop : forall (unop5:unop), forall (exp_val5:exp_val), P_exp_val exp_val5 -> forall (annot5:unit), P_exp_val (EV_Unop unop5 exp_val5 annot5))
  (H_EV_Binop : forall (binop5:binop), forall (exp_val1:exp_val), P_exp_val exp_val1 -> forall (exp_val2:exp_val), P_exp_val exp_val2 -> forall (annot5:unit), P_exp_val (EV_Binop binop5 exp_val1 exp_val2 annot5))
  (H_EV_Manyop : forall (exp_val_list:list exp_val), P_list_exp_val exp_val_list -> forall (manyop5:manyop), forall (annot5:unit), P_exp_val (EV_Manyop manyop5 exp_val_list annot5))
  (H_EV_Ite : forall (exp_val1:exp_val), P_exp_val exp_val1 -> forall (exp_val2:exp_val), P_exp_val exp_val2 -> forall (exp_val3:exp_val), P_exp_val exp_val3 -> forall (annot5:unit), P_exp_val (EV_Ite exp_val1 exp_val2 exp_val3 annot5))
  (H_list_exp_val_nil : P_list_exp_val nil)
  (H_list_exp_val_cons : forall (exp_val0:exp_val), P_exp_val exp_val0 -> forall (exp_val_l:list exp_val), P_list_exp_val exp_val_l -> P_list_exp_val (cons exp_val0 exp_val_l)).

Fixpoint exp_val_ott_ind (n:exp_val) : P_exp_val n :=
  match n as x return P_exp_val x with
  | (EV_Bits bv5 annot5) => H_EV_Bits bv5 annot5
  | (EV_Bool bool5 annot5) => H_EV_Bool bool5 annot5
  | (EV_Enum enum5 annot5) => H_EV_Enum enum5 annot5
  | (EV_Unop unop5 exp_val5 annot5) => H_EV_Unop unop5 exp_val5 (exp_val_ott_ind exp_val5) annot5
  | (EV_Binop binop5 exp_val1 exp_val2 annot5) => H_EV_Binop binop5 exp_val1 (exp_val_ott_ind exp_val1) exp_val2 (exp_val_ott_ind exp_val2) annot5
  | (EV_Manyop manyop5 exp_val_list annot5) => H_EV_Manyop exp_val_list (((fix exp_val_list_ott_ind (exp_val_l:list exp_val) : P_list_exp_val exp_val_l := match exp_val_l as x return P_list_exp_val x with nil => H_list_exp_val_nil | cons exp_val1 xl => H_list_exp_val_cons exp_val1(exp_val_ott_ind exp_val1)xl (exp_val_list_ott_ind xl) end)) exp_val_list) manyop5 annot5
  | (EV_Ite exp_val1 exp_val2 exp_val3 annot5) => H_EV_Ite exp_val1 (exp_val_ott_ind exp_val1) exp_val2 (exp_val_ott_ind exp_val2) exp_val3 (exp_val_ott_ind exp_val3) annot5
end.

End exp_val_rect.


(**********************************)

Inductive write_kind : Type :=
| Mk_write_kind : enum_ctor -> write_kind
.

Inductive proper_label : Type :=
| PLAB_read_reg (r : register_name) (v : valu) : proper_label
| PLAB_write_mem (kd : write_kind) (addr : valu) (val : valu) (ret : valu) (num_bytes : nat) (tag_value : bool) : proper_label
(* TODO: other cases *).

Inductive label : Type :=
| LAB_tau : label
| LAB_non_tau : proper_label -> label
.

Definition smt_var_map := isla_var -> option valu.

Definition isla_var_eqb (xv yv : isla_var) : bool :=
  match xv, yv with
  | Mk_isla_var x, Mk_isla_var y => Nat.eqb x y
  end.

  Definition option_bind {A B : Type} (f : A -> option B) (xo : option A) : option B :=
  match xo with
  | None => None
  | Some x => f x
  end.

Definition option_bind2 {A B C : Type} (f : A -> B -> option C) (xo : option A) (yo : option B) : option C :=
  match xo, yo with
  | None, _ => None
  | _, None => None
  | Some x, Some y => f x y
  end.


Definition eval_unop (u : unop) (v : valu) : option valu :=
  match u, v with
  | Not, Val_Bool b => Some (Val_Bool (negb b))
  | Not, _ => None
  | _, _ => (* TODO: other cases *) None
  end.


Fixpoint those_aux {A} (acc : option (list A)) (l : list (option A)) : option (list A) :=
  match acc with
  | None => None
  | Some ys_rev =>
    match l with
    | nil => Some ys_rev
    | cons x xs =>
      match x with
      | None => None
      | Some y => those_aux (Some (cons y ys_rev)) xs
      end
    end
  end.
  
  Definition those {A} (l : list (option A)) : option (list A) :=
  match those_aux (Some nil) l with
  | None => None
  | Some l => Some (List.rev l)
  end.

(** the ISLA-lang type "valu" allows symbols, which are not values in the sense of an operational semantics *)
Fixpoint eval_valu (v : valu) (rho : smt_var_map) {struct v} : option valu :=
  match v with
  | Val_Symbolic x => rho x
  | Val_Bool b => Some (Val_Bool b)
  | Val_I x i => Some (Val_I x i)
  | Val_Bits bs => Some (Val_Bits bs)
  | Val_Enum em => Some (Val_Enum em)
  | Val_String s => Some (Val_String s)
  | Val_Unit => Some Val_Unit
  | Val_NamedUnit u => Some (Val_NamedUnit u)
  | Val_Vector vs =>
    match those (List.map (fun x => eval_valu x rho) vs) with
    | None => None
    | Some vs' => Some (Val_Vector vs')
    end
    | Val_List vs =>
    match those (List.map (fun x => eval_valu x rho) vs) with
    | None => None
    | Some vs' => Some (Val_List vs')
    end
  | Val_Struct s => Some (Val_Struct s)
  | Val_Poison => Some (Val_Poison)
  end.


Definition eval_binop (b : binop) (v1 v2 : valu) : option valu :=
  match b, v1, v2 with
  | Eq, Val_Bool b1, Val_Bool b2 => Some (Val_Bool (Bool.eqb b1 b2))
  | _, _, _ => (* TODO: other cases *) None
  end.

Fixpoint eval_exp (e : exp) (rho : smt_var_map) : option valu :=
  match e with
  | Var x _ => rho x
  | Bits n _ => Some (Val_Bits n)
  | Bool b _ => Some (Val_Bool b)
  | Enum em _ => Some (Val_Enum em)
  | Unop uo e' _ =>
    option_bind (eval_unop uo) (eval_exp e' rho)
  | Binop uo e1 e2 _ =>
    option_bind2 (eval_binop uo) (eval_exp e1 rho) (eval_exp e2 rho)
  | Manyop _ _ _ => None (* TODO *)
  | Ite e1 e2 e3 _ =>
    match eval_exp e1 rho with
    | Some (Val_Bool true) => eval_exp e2 rho
    | Some (Val_Bool false) => eval_exp e3 rho
    | _ => None
    end
  end.

Inductive event_step : event -> smt_var_map -> label -> smt_var_map -> Prop :=
| es_declare_const rho x ty v ann :
  rho x = None ->
  event_step (Smt (DeclareConst x ty) ann) rho LAB_tau (fun y => if isla_var_eqb x y then Some v else rho y)
| es_assert rho e ann :
  eval_exp e rho = Some (Val_Bool true) ->
  event_step (Smt (Assert e) ann) rho LAB_tau rho
| es_read_reg rho r al v ann :
  event_step (ReadReg r al v ann) rho (LAB_non_tau (PLAB_read_reg r v)) rho
| es_write_mem rho ret_sym x_sym v_sym wkd_sym num_bytes tag_value_sym al x v ret wkd tag_value :
  (* TODO: What to do with tag_value? *)
  eval_valu x_sym rho = Some x ->
  eval_valu v_sym rho = Some v ->
  eval_valu (Val_Symbolic ret_sym) rho = Some ret ->
  eval_valu wkd_sym rho = Some (Val_Enum wkd) ->
  event_step (WriteMem ret_sym wkd_sym x_sym v_sym num_bytes tag_value_sym al) rho (LAB_non_tau (PLAB_write_mem (Mk_write_kind (snd wkd)) x v ret num_bytes tag_value)) rho
(* TODO: other cases *)
.

Record sequential_state := {
  seqst_reg_map : register_name -> valu;
  seqst_mem_map : valu -> option valu;
}.


Fixpoint valu_eqb (v1 v2 : valu) : bool :=
  match v1, v2 with
  | Val_Bool b1, Val_Bool b2 => Bool.eqb b1 b2
  | _, _ => false (* TODO: other cases *)
  end.

Definition write_byte (addr : valu) (value : valu) (s : sequential_state)
: sequential_state :=
  {| seqst_reg_map := s.(seqst_reg_map);
     seqst_mem_map := fun y => if valu_eqb addr y then Some value else s.(seqst_mem_map) y |}.

(* It's not clear to me exactly how this should work *)
Axiom split : valu -> valu * valu.

(*
Definition write_bytes
  (addr : valu)
  (sz : Z)
  (value : valu)
  (s : sequential_state)
  : sequential_state.
Proof.
  Local Close Scope Z.
  refine ((z_ind (fun x => valu -> sequential_state) _ _ sz) value).
  + intros v'.
    exact s.
  + intros x H ind v'.
    assert (v'' : mword (8 + 8*x)).
    - refine (cast_T v' _).
      apply eq_sym.
      apply pluseight.
    - pose (v''':=mword_split v'').
      destruct v''' as [a b].
      pose (s' := ind b).
      pose (addr' := addr_offset addr (sz-x)).
      exact (write_byte addr a s').
Defined.
*)

Inductive sequential_state_step : sequential_state -> proper_label -> sequential_state -> Prop :=
| seqststep_read_reg seqst r v :
  seqst.(seqst_reg_map) r = v ->
  sequential_state_step seqst (PLAB_read_reg r v) seqst
| seqststep_write_mem seqst ret wkd x v num_bytes tv :
  (* TODO: this assumes every write is of one byte *)
  sequential_state_step seqst (PLAB_write_mem ret wkd x v num_bytes tv)
    {| seqst_reg_map := seqst.(seqst_reg_map);
       seqst_mem_map := fun y => if valu_eqb x y then Some v else seqst.(seqst_mem_map) y |}
(* TODO: other cases *).

Record sequential_system_state := {
  seqsysst_smt_var_map : smt_var_map;
  seqsysst_seq_st : sequential_state;
}.

Inductive sequential_system_head_step :
  event -> sequential_system_state ->
  sequential_system_state ->
  Prop :=
| seq_sys_step_tau e seqsysst rho rho' :
  event_step e rho LAB_tau rho' ->
  sequential_system_head_step
    e
    {| seqsysst_smt_var_map := rho; seqsysst_seq_st := seqsysst |}
    {| seqsysst_smt_var_map := rho'; seqsysst_seq_st := seqsysst |}
| seq_sys_step_non_tau e rho seqsysst plab rho' seqsysst' :
  event_step e rho (LAB_non_tau plab) rho' ->
  sequential_state_step seqsysst plab seqsysst' ->
  sequential_system_head_step
    e
    {| seqsysst_smt_var_map := rho; seqsysst_seq_st := seqsysst |}
    {| seqsysst_smt_var_map := rho'; seqsysst_seq_st := seqsysst' |}
.

Inductive trace_system_step : trc -> sequential_system_state -> trc -> sequential_system_state -> Prop :=
| tss_cons e es sys sys' :
  sequential_system_head_step e sys sys' ->
  trace_system_step (Trace (e :: es)) sys (Trace es) sys'
.

Definition instruction := list trc.

Inductive trace_step : trc -> smt_var_map -> label -> trc -> smt_var_map -> Prop :=
| ts_cons e es rho lab rho' :
  event_step e rho lab rho' ->
  trace_step (Trace (e :: es)) rho lab (Trace es) rho'
.

Definition rho0 : smt_var_map := (fun _ => None).

Definition related_label (l1 l2 : proper_label) : Prop :=
  match l1, l2 with
  | PLAB_read_reg r1 v1, PLAB_read_reg r2 v2 =>
    r1 = r2
  | PLAB_write_mem kd1 x1 v1 ret1 num_bytes1 tag_value1,
    PLAB_write_mem kd2 x2 v2 ret2 num_bytes2 tag_value2 =>
    (* TODO: tag_value? *)
    kd1 = kd2 /\ num_bytes1 = num_bytes2 /\ x1 = x2
  | _, _ => False
  end.

Inductive trace_any_steps : trc -> smt_var_map -> trc -> smt_var_map -> Prop :=
| trace_any_steps_refl trc rho :
  trace_any_steps trc rho trc rho
| trace_any_steps_step trc rho lab trc' rho' trc'' rho'' :
  trace_step trc rho lab trc' rho' ->
  trace_any_steps trc' rho' trc'' rho'' ->
  trace_any_steps trc rho trc'' rho''
.

(* A set of traces counts as a proper instruction,
  when it never gets stuck: there is always another trace
  that can read another value *)
Definition instruction_is_live (i : instruction) : Prop :=
    forall (tr : trc) tr1 tr' rho1 rho' lab,
    (exists trs1 trs2, i = trs1 ++ (tr :: trs2)) ->
    trace_any_steps tr rho0 tr1 rho1 ->
    trace_step tr1 rho1 (LAB_non_tau lab) tr' rho' ->
    forall lab',
    related_label lab lab' ->
    exists tr'' rho'',
    trace_step tr rho1 (LAB_non_tau lab') tr'' rho''
.

(* TODO: chain multiple instructions *)


